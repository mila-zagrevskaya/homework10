<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HOMEWORKS FEA-12</title>
	<link rel="stylesheet" href="css/style.css">
	<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,700" rel="stylesheet">
	<link rel="stylesheet" href="css/style.css">
	<link rel="shortcut icon" href="images/favicon.png">
	
</head>
<body onload = "showCode (exercise1, '.show-code1' ) , showCode (exercise2, '.show-code2')">
	<div class="wrap">
		<div class="wrapper">
			<h1>Загревская Людмила <br>fea-12</h1>
			<div class="exercise">
				<h2> exercise 10.1</h2>
				<p class = 'description bold'>Логирование поступающих сообщений в объекте log
				</p>
				<p class = 'description'>Задан массив сообщений и пустой объект log:
				</p>
				<p class="description">
					<pre class="description">
		let messages = [
		    "backspace",
		    "enter",
		    "shift",
		    "control",
		    "delete",
		    "space",
		    "subtract"
		]
		var log = {}
					</pre>
				</p>
				<p class = 'description'>Далее, есть функция, отправляющая сообщения в случайном порядке в случайное время:
				</p>
				<p>
					<pre class="description">
		var sendMessage = ( message, callback ) => 
		    setTimeout (
		        () => callback ( message ),
		        Math.random () * 7000
		    )
					</pre>
				</p>
				<p class = 'description'>Обратите внимание, что эта функция получает при вызове не только текст сообщения, но и кoлбэк-функцию, которой нужно передать это сообщение <br><br>С помощью кода:
				</p>
				<p>
					<pre class="description">
		messages.forEach (
		    message => sendMessage ( message, handler )
		)
					</pre>
				</p>
				<p class = 'description'>инициируем отправку сообщений <br><br>!warning:<br><br>Ваша задача - напилить код функции handler, которая получает сообщение и заносит его в объект log <br> в виде нового свойства, значение которого - текст поступившего сообщения, <br> а ключ ( имя свойства ) - это время поступления сообщения ( в виде строки )
				</p>
				<p>
					<pre class="description">
		{
		    19:34:08: "control"
		    19:34:08[2]: "backspace"
		    19:34:09: "subtract"
		    19:34:09[2]: "enter"
		    19:34:11: "delete"
		    19:34:11[2]: "shift"
		}
					</pre>
				</p>
				<p class = 'description'>В помощь вам уже есть функция, которая формирует ключ очередного сообщения:
				</p>
				<p>
					<pre class="description">
		getKey = () => {
		    var key = new Date().toLocaleString().split(", ")[1]
		    return log [ key ] ? key + "[2]" : key
		}
					</pre>
				</p>
				<p class = 'description'>На случай, если два сообщения поступят одновременно, функция getKey добавляет "[2]" к значению ключа ( иначе значения ключей двух сообщений будут совпадать )
				</p>
				<pre class="show-code1">
					
				</pre>
				<!-- <div class="result1"></div> -->
				<button name = "btn" class="btn" onclick = "exercise1()"> Show result in console </button>
			</div>

			<div class="exercise">
				<h2>exercise  10.2</h2>
				<p class = 'description'>Допилите код конструктора User, дополнив его акцессорами приватного свойства presence так, чтобы после выполнения скрипта:
				</p>
				<p>
				<pre class="description">
		function User ( name ) {
		    this.name = name
		    var presence = false
		    ...
		}
		let user = new User ( "Ivan" )
		console.info ( user.presence )
					</pre>
				</p>
				<p class = 'description'>в консоли было: <br><br> "Ivan is absent" <br><br> а после выполнения кода:
				</p>
				<p>
					<pre class="description">
		user.presence = "+" 
		console.info ( user.presence )
					</pre>
				</p>
				<p class = 'description'>в консоли было: <br><br> "Ivan is present"
				</p>
				<pre class="show-code2">
					
				</pre>
				<!-- <div class="result2"></div> -->
				<button name = "btn" class="btn" onclick = "exercise2()"> Show result in console </button>
			</div>
			<div class="exercise">
				<h2>exercise  10.3</h2>
				<p class = 'description'>Объявить функцию-конструктор User
				</p>
				<p class = 'description'>!warning: Конструктор должен принимать аргументы, описывающие юзера
				</p>
				<p class = 'description bold'>Статические свойства и методы конструктора
				<p class = 'description'>У конструктора должны быть следующие :warning: не наследуемые экземплярами свойства и методы:
				</p>
				<p>
					<pre class="description">
:1: avatars
массив:

[
     "https://pre00.deviantart.net/50f9/th/pre/i/2011/217/e/8/pikachu_2_by_nostalgiaattack-d45jd3i.png",
     "https://cdn.diversityavatars.com/wp-content/uploads/2018/01/Vector-Smart-Object-5.png",
     "https://cdn4.iconfinder.com/data/icons/user-avatar-flat-icons/512/User_Avatar-31-512.png",
     "http://icons.iconarchive.com/icons/hopstarter/face-avatars/256/Male-Face-L3-icon.png",
     "https://findicons.com/files/icons/1072/face_avatars/300/i05.png",
     "http://www.iconarchive.com/download/i51043/hopstarter/halloween-avatars/Gomez.ico",
     "http://icons.iconarchive.com/icons/hopstarter/halloween-avatars/256/Zombie-2-icon.png",
     "https://vignette.wikia.nocookie.net/yogscast/images/8/8a/Avatar_Turps_2015.jpg"
]
					</pre>
				</p>
				<p>
					<pre class="description">
:2: admin
объект следующей структуры:

{
    photoURL: "https://i.pinimg.com/originals/3d/47/4f/3d474f82ff71595e8081f9a120892ae8.gif",
    name: "admin"
}	

Админ пишет непосредственно в messageBox
					</pre>
				</p>
				<p>
					<pre class="description">
:3: getAvatar
метод, возвращающий извлеченный из массива avatars элемент

return this.avatars.shift ()
					</pre>
				</p>
				<p class = 'description bold'>Собственные свойства экземпляров </p>
				<p class = 'description'>
					<ol class = "props">
						<li>name ( имя пользователя )</li>
						<li> email</li>
						<li>photoURL ( URL фотографии пользователя )
							<ul class = "props">
								<li>Конструктор должен иметь дефолтные значения для всех аргументов</li>
								<li>дефолтное значение URL фотографии пользователя должно быть результатом работы статического метода getAvatar</li>
							</ul>
						</li>
					</ol>
				</p>
				<p class = 'description bold'>Унаследованные свойства экземпляров</p>
				<p class = 'description'>
					<ol class = "props">
						<li>неперечислимое неизменяемое свойство messageBox - элемент DOM
							<ul class = "props">
								<li>messageBox - это контейнер, куда будут выводиться сообщения всех пользователей и admin</li>
								<li>при выводе сообщения пользователя в messageBox должны отображаться его аватар и имя</li>
							</ul>
						</li>
						<li> унаследованные методы write и read
							<ul>
								<li>запись осуществляется в messageBox, чтение - из messageBox</li>
							</ul>
						</li>
					</ol>
				</p>
				<p class = 'description bold'>После того, как конструктор будет объявлен, выполните код в консоли: </p>	
				<p>
					<pre class="description">
var users = [
    new User ( "Иван" ),
    new User ( 'Alex', "alex@gmail.com" ),
    new User ( 'Bob', "bob777@gmail.com" ),
    new User ( 'Dima', "dima888@gmail.com" ),
    new User ( 'Fima', "fima999@gmail.com" )
]

var k = 1
users.forEach ( 
    function ( user ) {
        setTimeout ( 
            function () {
                user.write ( `Hello, I'm ${user.name}` )
            }, 3000 * k++
        )
    }
)
					</pre>
				</p>
				<p class = 'description'>Короче, юзеры пишут в messageBox из консоли: <br><br>
				users[index].write ( text ) <br><br>
				а вот админ - непосредственно вводит текст в messageBox ( т.е. при вводе в messageBox пишущий сообщение идентифицируется как админ, выводится его аватар и имя ) 
				</p>
				<pre class="show-code3">
	var User = function ( name = "user",
                      email = "user@sample.com",
                      photo = User.getAvatar() ) {
        this.name = name
        this.email = email
        this.photoURL = photo
        this.info = ''
	}

	User.admin = {
    	photoURL: "images/admin.png",
    	name: "admin"
	}
	User.getAvatar = function () {
    	return this.avatars.shift ()
	}
	User.avatars = [
    	"images/1016-340.png",
    	"images/1539459376_9e4d7587-71d1-42b6-a8c2-69edd290e13f.png", 
    	"images/1539459158_a56026bf-542b-4d77-8abf-9b41f0dd6869.png", 
    	"images/princess-jasmine.png",
    	"images/a5765d4a-ffe1-4359-9701-72bc770bce36.png", 
    	"images/d030f52a-321d-4e61-9251-9dfc62844d30.png",
    ]

    User.prototype.messageBox = ( function () {
        var box = document.createElement ( 'div' )
        document.querySelector (".result3").appendChild ( box )
        box.className = "mess-box"
        box.picture = box.appendChild ( document.createElement ( 'img' ) )
        box.picture.style.width = "100px"
        box.name = box.appendChild ( document.createElement ( 'span' ) )
        box.name.style = "font-weight: bold; color: #9ab; padding-left:10px;"
        box.message = box.appendChild ( document.createElement ( 'textarea' ) )
         box.message.placeholder = "Сообщение"
        box.message.oninput = function ( event ) {
                event.target.parentNode.querySelector ( 'img' ).src = User.admin.photoURL
                event.target.parentNode.querySelector ( 'span' ).innerHTML = User.admin.name
        }
        box.message.style = "width: 100%; height: 100%; margin-top: 10px;"
        return box
    })()

	User.prototype.write = function ( text ) {
        this.messageBox.picture.src = this.photoURL
        this.messageBox.name.innerHTML = this.name
        this.messageBox.message.value = text
    }
    User.prototype.read = function () {
        this.messageBox.picture.src = this.photoURL
        this.messageBox.name.innerHTML = this.name
        this.info = this.messageBox.message.value
        console.log ( `${this.name} прочитал сообщение:\n${this.info}` )
        this.messageBox.message.value = "OK"
    }

    var users = []
    users.push ( new User ( "Elza" ) )
    users.push ( new User ( 'Rapunzel', "alex@gmail.com" ) )
    users.push ( new User ( 'Cinderella', "сinderella777@gmail.com" ) )
    users.push ( new User ( 'Jasmine', "dima888@gmail.com" ) )
    users.push ( new User ( 'Snow White', "fima999@gmail.com" ) )

    var index = 1
    users.forEach ( 
         function ( user ) {
              setTimeout ( 
                   function () {
                        user.write ( `Hello, I'm ${user.name}` )
                   }, 3000 * index++
              )
    } )
					
				</pre>
				<div class="result3"></div>
				<div class="buttons">
					<button name = "btn" class="btn" onclick = "exercise3()"> users[0].write</button>
					<button name = "btn" class="btn" onclick = "exercise31()"> users[1].read</button>
					<button name = "btn" class="btn" onclick = "exercise32()"> users[2].write</button>
					<button name = "btn" class="btn" onclick = "exercise33()"> users[4].write</button>
				</div>
			</div>
		</div>

<script src = "js/index101.js"></script>
<script src = "js/index102.js"></script>
<script src = "js/index103.js"></script>		
</body>
</html>